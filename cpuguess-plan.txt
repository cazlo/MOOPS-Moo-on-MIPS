Determine cows

word array 0-F
nn yy gg gg gg gg gg gg
0 = unknown
gggggg = number of times it's come up as possible
nn = 80 for definite no
yy = 80 for definite yes

output 4 digits
if cows = 4, done
if any cows, increment all 4 by number of cows in block
if no cows, set all 4 as definite no


Phase 1
Get cow status
Use hardcoded map to get down to two blocks, one with 3 cows

Hardcoded pick-third map
0: 0123 4567 89AB CDEF
1: 0369 CF25 8BEI 47AD
2: 092B 4D6F 81A3 C5E7
3: 0B61 C72D 83E9 4FA5

Hardcoded pick-fifth map
0: 0123 4567 89AB CDEF
1: 05AF 49E3 8D27 C16B
2: 092B 4D6F 81A3 C5E7
3: 0DA7 41EB 852F C963

Hardcoded pick-fifth, alternative start (hides pattern somewhat)
0: 0123 4567 89AB CDEF
1: 49E3 8D27 C16B 05AF
2: 81A3 C5E7 092B 4D6F
3: C963 0DA7 41EB 852F


using fifths (first opt)

round 0:
ex: 8B5C
0123 4567 89AB CDEF
nnnn 1111 2222 1111

round 1:
05AF 49E3 8D27 C16B
n121 121n 21n1 1n12

5AF4 9E8D 7C6B
1211 2121 1112 before
1111 1111 2222 add
2311 3232 3334 after

round 2:
092B 4D6F 81A3 C5E7
n3n4 1231 3n3n 3223

ex: 8B5C
9B4D 6F8A C5E7
3412 3133 3223 before
1111 1111 2222 add
4523 4244 5445 after

round 3:
0DA7 41EB 852F C963
n345 2n45 44n2 544n

ex: 8B5C
DA74 EB85 FC96
3452 4544 2544 before
nnnn 3333 1111 add
nnnn 7877 3655 after

round 4, if needed, would return to map 0
0123 4567 89AB CDEF
nnnn n75n 75n8 6n73


End phase 1, we have a block with 3 cows. (wonder if we ever *don't* get there?)
We can't get past here with what we have, because our hardcodes don't include all possibilities


Phase 2
(future: Order each by likelihood. No order-by right now.)
Start swapping from 1-cow into 3-cow

if cows = 4, done

if cows = 2:
* swapped-out digit is a cow (definite yes)
* swapped-in digit is a goat (definite no)
* Pick next digit from each and repeat

if cows = 3, swapped-out digit and swapped-in digit are the same type. Go to phase 3.


Phase 3
We have a digit in the 3-cow and a digit in the 1-cow that are the same type

Get next digit from the 1-cow, swap it with current digit from the 3-cow

if cows = 4, done

if cows = 3:
* swapped-out digit is a goat (definite no)
* old swapped-in digit is a goat (definite no)
* new swapped-in digit is a goat (definite no)
* Go to phase 4b

if cows = 2:
* swapped-out digit is a cow (definite yes)
* old swapped-in digit is a cow (definite yes)
* new swapped-in digit is a goat (definite no)
* Go to phase 4a


Phase 4a
We have a 3-cow, and a known good digit from 1-cow

Swap known good digit with unknown digit in 3-cow

if cows = 4, done

if cows = 3:
* swapped-out digit is a cow (definite yes)
* Repeat phase 4a


Phase 4b
We have a 3-cow and we know which digit is bad, but we don't know which digit in 1-cow is good
Only 2 choices at this point, though.

Swap first unknown. If cows = 4, done, else swap second unknown and that's it.


Phase 2+ test
ex: 8B5C

3-cow: EB85
1-cow: FC96

Phase 2
swap 3/ch1 w 1/ch1: FB85, cows = 3: E & F are the same type

Phase 3
swap 3/ch1 w 2/ch2: CB85, cows = 4: done
